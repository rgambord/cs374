<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Module 4: Processes &mdash; CS 374 - Operating Systems  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=2e9965fa" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/css/lightbox.css?v=5c84f910" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/brand.css?v=629ae113" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.svg"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=7a06361e"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
        <script src="../../../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/js/lightbox-plus-jquery.min.js?v=ffc8af2d"></script>
        <script src="../../../_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js?v=12818e64"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #D73F09" >

          
          
          <a href="../../../" class="icon icon-home">
            CS 374 - Operating Systems
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Course Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/syllabus/">Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/schedule/">Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/os1_setup/">OS1 Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/style/">Style Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../01/">Operating Systems Fundamentals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../01/introduction/">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/introduction/overview/">Operating Systems Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/introduction/history-of-unix/">A Brief History of Unix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/introduction/standards/">Standards and Specifications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/introduction/linux-dist/">Linux Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/introduction/c-language/">The C Programming Language</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/processes/">Processes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/virtual-memory/">Virtual Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/system-call-interface/">System Call Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/hierarchy/">Process Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/identity/">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/file-system-access/">File System Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/processes/inter-process-communication/">Inter-process Communication</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/filesystem/">File Systems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/mounting/">Mounting and Unmounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/structure/">Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/permissions/">Permissions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/metadata/">Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/fhs/">The Filesystem Hierarchy Standard</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/filesystem/additional-concepts/">Additional Concepts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/terminal/">Terminal Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/terminal/operating-modes/">Terminal Operating Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/terminal/control-codes/">Control Codes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/utilities/">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/shell/">The Interactive Shell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/simple_commands/">Simple Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/quoting/">Quoting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/expansion/">Expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/variable_assignment_and_redirection/">Variable Assignment and Redirection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/command_execution/">Command Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/pipelines/">Pipelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell/background/">Background Commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/vim/">Software Development in Vim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/shell_command_language/">The Shell Command Language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell_command_language/noninteractive_shell/">The Non-interactive Shell</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell_command_language/parameters/">Shell Parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/parameters/positional_parameters/">Positional Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/parameters/special_parameters/">Special Parameters</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell_command_language/control_flow/">Control Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/background/reserved_words_and_operators/">Reserved Words and Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/background/exit_status/">Exit Status</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/background/shell_grammar/">Shell Grammar</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/compound_commands/grouping_constructs/">Grouping Constructs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/compound_commands/loops/">Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/compound_commands/conditional_constructs/">Conditional Constructs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/control_flow/function_definition/">Function Definition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell_command_language/builtins/">Builtins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/builtins/aliases/">Alias Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/builtins/getopts/">Options Processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/builtins/file_access_and_creation/">File Access and Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/builtins/parameters_and_options/">Parameters and Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../01/shell_command_language/builtins/signals/">Signal Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../01/shell_command_language/executable_scripts/">Executable Shell Scripts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../01/assignments/">Assignments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../02/">Introduction to C Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../02/assignments/">Assignments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/overview/">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/type-system/">Type System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../02/type-system/integer-types/">Integer Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../02/type-system/special-integer-types/">Special Integer Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../02/type-system/floating-types/">Floating Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../02/type-system/special-types/">Special Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../02/type-system/derived-types/">Derived Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../02/object-model/">Object Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/identifiers/">Identifiers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../02/identifiers/declaration-syntax/">Declaration Syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../02/identifiers/declaration-syntax/declaration-specifiers/">Declaration Specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../02/identifiers/declaration-syntax/declarators/">Declarators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../02/identifiers/practical-declarations/">Practical Declarations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../02/identifiers/practical-declarations/functions/">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../02/identifiers/practical-declarations/objects/">Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../02/identifiers/practical-declarations/types/">User-Defined Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../02/expressions/">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/abstract-machine-model/">Abstract Machine Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../02/abstract-machine-model/statements-and-structure/">Statements and Structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../02/preprocessor-language/">Preprocessor Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/standard-library/">Standard Library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../03/">Data Access and Storage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../03/file-system-concepts/">File System Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../03/file-system-concepts/background/">File System History</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/file-system-concepts/structure/">File System Structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../03/stdio/">The C Standard Input/Output Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../03/stdio/motivation/">Motivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/stdio/access/">File Access and Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/stdio/io/">Input/Output Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../03/stdio/io/character/">Character i/o</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../03/stdio/io/direct/">Direct i/o</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../03/stdio/io/string/">String i/o</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../03/stdio/io/formatted/">Formatted i/o</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../03/variadic/">Variadic Functions</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../03/stdio/io/formatted/printf-family/">Formatted Output</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../03/stdio/io/formatted/scanf-family/">Formatted Input</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../03/posix-io/">POSIX I/O</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../03/posix-io/fcntl/">File Control Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/posix-io/io/">File I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/posix-io/stdio/">Standard I/O Extensions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../03/memory-management/">Memory Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../03/memory-management/standard-c/">Standard C Allocations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../03/memory-management/posix/">POSIX Allocations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../03/assignments/">Assignments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../05/">Inter-Process Communication</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../05/signals/">Signals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../05/signals/sending/">Sending Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/signals/receiving/">Receiving Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/signals/async-safety/">Asynchronous Signal Safety</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../05/file-system/">File System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/regular-files/">Regular Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/special-files/">Special Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/drivers/">The Role of Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/fifos/">FIFOs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/unix-sockets/">UNIX Domain Sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/file-descriptors/">Understanding File Descriptors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/file-system/memory-maps/">Memory Mappings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../05/networking/">Networking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../05/networking/stream-sockets/">Stream Sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/networking/tcp-client/">TCP Client Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../05/networking/tcp-server/">TCP Server Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../05/assignments/">Assignments</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">BigShell</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../assignments/bigshell/">Specification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../assignments/bigshell/shell_command_language/">BigShell Command Language</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://www.gradescope.com/courses/801266/assignments/4646362/submissions" rel="noopener noreferrer" target="_blank">GradeScope</a></li>
<li class="toctree-l1"><a class="reference external" href="https://classroom.github.com/a/wz3vJVkk" rel="noopener noreferrer" target="_blank">Starter Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/github_setup/">GitHub/os1 Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../assignments/bigshell-report/">Final Report</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://oregonstate.edu" rel="noopener noreferrer" target="_blank">Oregon State University</a></li>
<li class="toctree-l1"><a class="reference external" href="https://canvas.oregonstate.edu" rel="noopener noreferrer" target="_blank">Canvas</a></li>
<li class="toctree-l1"><a class="reference external" href="https://edstem.org" rel="noopener noreferrer" target="_blank">Ed Discussions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://teams.microsoft.com" rel="noopener noreferrer" target="_blank">Microsoft Teams</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../meta/glossary/">Glossary</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../meta/glossary/c/">Glossary of C Language Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../meta/glossary/operating-systems/">Glossary of Operating Systems Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../meta/glossary/computer-science/">Glossary of Computer Science Terminology</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex/">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #D73F09" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../">CS 374 - Operating Systems</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Module 4: Processes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-4-processes">
<h1>Module 4: Processes<a class="headerlink" href="#module-4-processes" title="Link to this heading"></a></h1>
<section id="what-is-a-process">
<h2>What is a Process?<a class="headerlink" href="#what-is-a-process" title="Link to this heading"></a></h2>
<p>A <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-process"><span class="xref std std-term">process</span></a> is an instance of a <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-program"><span class="xref std std-term">program</span></a> that is running on a computer, also called a running program. To write a program, we are probably using a text editor (like vim) that creates a file with the instructions in some predefined computer language (like C). The instructions in this file are later translated to instructions in machine language by a compiler (like gcc). A successful compilation generates another file containing the translated instructions. To run this compiled file in the computer, the operating system must load its instructions in the computer’s memory and make them ready to take control of the computer. It is only then that we can consider it to be a process, and it will remain a process until the operating system terminates it.</p>
<p>Notice that we are using other programs and processes to generate our program. The text editor and the compiler are collections of many files with instructions that help us write code and create executable files, respectively. To perform these activities, the files of these programs need to run on the computer. When they are running, they also become processes. Any program running on a computer is a process.</p>
<p>The operating system has at its core a set of instructions known as the :term;`kernel`. The kernel is the actual manager of the computer and handles all its operations. Among other things, it decides everything about the processes: when can they run, how to run and for how long. It also allocates resources for these processes: CPU to run, memory, files and peripherals. The kernel itself is not a process.</p>
<p>While working, the operating system is constantly switching between two modes of operation, the kernel mode and the user mode. In kernel mode, the kernel is in control of all operations. It can perform any activity in the computer without any restriction. When there are processes to run, the kernel selects one of them, loads it in memory, assigns resources to it and switches to user mode, to let the process take control of the computer, but in a restricted fashion. The process can only perform activities over the resources that it has control. If the process were to require more resources, like more memory, or access to a device, or even terminate, it must request the kernel for these actions to be performed. When it does, the kernel regains control of the computer in kernel mode and decides to grant or not these resources, to let the process continue in user mode again, or to grant access to the CPU to another process in user mode again.</p>
</section>
<section id="processes-and-the-file-system">
<h2>Processes and the File System<a class="headerlink" href="#processes-and-the-file-system" title="Link to this heading"></a></h2>
<p>When a process starts, it is assigned a <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a> that is inherited from its parent process, unless it is a shell process which gets its assignment from the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-home-directory"><span class="xref std std-term">home directory</span></a> of the user who creates the shell. The <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-home-directory"><span class="xref std std-term">home directory</span></a> is part of the information stored for every user in the password file for the system. Processes use their <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a> to discover the location of files within the file hierarchy.</p>
<p>There are two ways to indicate the placement of files in the file system. The <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-absolute-pathname"><span class="xref std std-term">absolute pathname</span></a> describes the position of a file starting at the root. For example, in the figure above, the absolute pathname for the file <code class="file docutils literal notranslate"><span class="pre">myprog.c</span></code> is <code class="file docutils literal notranslate"><span class="pre">/home/master/myprog.c</span></code> . Notice that an absolute pathname always begins with the slash (<code class="file docutils literal notranslate"><span class="pre">/</span></code>) for the root directory. That is its give away. In an absolute pathname we write the name of every directory in the path from root to the required file, each name separated by slashes. The other way to indicate file placement is with the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-relative-pathname"><span class="xref std std-term">relative pathname</span></a>, and this is where the current working directory is needed. A relative pathname for a process is based on its <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>. For example, if the user named <strong>master</strong> opens a shell, and its <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-home-directory"><span class="xref std std-term">home directory</span></a> is <code class="file docutils literal notranslate"><span class="pre">/home/master</span></code>, then this will also be its <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>. Now, under these circumstances, all that the shell needs to do to refer to the file <code class="file docutils literal notranslate"><span class="pre">myprog.c</span></code> is to name it, because it is already placed in its current working directory. There is no need to add any directory name.If on the other hand, the shell wants to refer to the file named <code class="file docutils literal notranslate"><span class="pre">data</span></code> under the <code class="file docutils literal notranslate"><span class="pre">margaret</span></code> directory, it will have to indicate the path to this file from the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>. This will go something like this: <code class="file docutils literal notranslate"><span class="pre">../margaret/data</span></code> . Notice this time that the relative pathname does not begin with the slash for the root directory, instead it begins with the dot-dot (<code class="file docutils literal notranslate"><span class="pre">..</span></code>), indicating that from the <code class="file docutils literal notranslate"><span class="pre">master</span></code> directory (the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>), the search must go up to its parent directory (<code class="file docutils literal notranslate"><span class="pre">home</span></code>), and from there it should go down to the directory named <code class="file docutils literal notranslate"><span class="pre">margaret</span></code> to find the file <code class="file docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>While in the shell, the user may change its <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a> with the command <strong class="program">cd</strong>. This command takes a pathname as a parameter (absolute or relative) which becomes the new <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>. Used without parameters, <strong class="program">cd</strong> moves the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a> backs to the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-home-directory"><span class="xref std std-term">home directory</span></a>. If a C program wants to retrieve the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>, it may use the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getcwd</span></code> system call that returns it as string (<code class="code highlight c c99 docutils literal highlight-c99"><span class="k">char</span><span class="w"> </span><span class="o">*</span></code>). The parameters for this function call are a string with enough space to receive the pathname and the size of this string. If that string is not long enough, the function call will fail. To change this <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-current-working-directory"><span class="xref std std-term">current working directory</span></a>, the C program may use the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">chdir</span></code> system call that takes the new pathname as a parameter and returns the integer 0 for success or -1 in error. The prototypes for both system calls are as follows:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">getcwd</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cwdbuf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">chdir</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pathname</span><span class="w"> </span><span class="p">)</span>
</pre></div>
</div>
<p>To access a file, it is not enough to know the placement of a file in a
file system, we must also be aware of the file permissions granted to
the file. File permissions are divided in three groups: permissions for
the owner of a file, permissions for the group to which the file
belongs, and permissions for anyone else. Each one of these groups may
have the following permissions: permission to <strong>read</strong> the file,
permission to <strong>write</strong> on the file and permission to <strong>execute</strong> the
file (used if the file is a compiled program or a script). The same
permissions are granted for directories, but with slight different
meanings. Reading a directory means to be able to see its contents,
writing in a directory means to be able to modify its contents, but the
execution permission is actually a search permission. It allows for the
search of a particular entity inside the directory.</p>
<p>We can observe the permissions on every file or directory if we use the
command <strong class="command">ls -la</strong>. The following figure shows samples of this command
applied to the directories <strong>master</strong> and <strong>margaret</strong> in the file
system depicted before, by user named <strong>master</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $ls -la</span>
<span class="go">drwx------   21 master   master    4096 Jun  5 22:14 .</span>
<span class="go">drwx-xr--x    3 root     root        20 Apr  2 16:40 ..</span>
<span class="go">-rw-r--r–     1 master   master    1167 Jul 26 12:36 myprog.c</span>
<span class="go">master $ls -la ../margaret</span>
<span class="go">drwx------    3 margaret margaret  4096 May  6 11:10 .</span>
<span class="go">drwx-xr--x    3 root     root        20 Apr  2 16:40 ..</span>
<span class="go">-rw-r--r–     1 margaret margaret 10423 Jun  6 17:14 data</span>
<span class="go">master $</span>
</pre></div>
</div>
<p>The results presented by this command show the permissions on the left
side. The first character indicates that kind of file being observed
(<code class="docutils literal notranslate"><span class="pre">-</span></code> for a regular file, <code class="docutils literal notranslate"><span class="pre">d</span></code> for a directory). This is followed by
three sets of three characters, for user, group and other users. For
each of these sets there is a character for the read permission (<code class="docutils literal notranslate"><span class="pre">r</span></code>),
the write permission (<code class="docutils literal notranslate"><span class="pre">w</span></code>) or the execute/search permission(<code class="docutils literal notranslate"><span class="pre">x</span></code>). If
any of these permissions is not granted, then a dash (<code class="docutils literal notranslate"><span class="pre">-</span></code>) is being
displayed instead. For example, the <code class="file docutils literal notranslate"><span class="pre">myprog.c</span></code> and <code class="file docutils literal notranslate"><span class="pre">data</span></code> files both
allow read and write permissions for the owners (<strong>master</strong> and
<strong>margaret</strong>, respectively) , and read only permissions for their group
and everyone else.</p>
<p>After the permissions, the results of the command also show the number
of links the file has, the owner of the file, the group to which it
belongs, the size in bytes, the last date and time that was modified and
the file name and extension. With the permissions above, if the <strong>master</strong>
user wants to read the data file in the <code class="file docutils literal notranslate"><span class="pre">margaret</span></code> directory, it may do so
because read permissions have been granted to everyone. However, if it
tries to modify it, it cannot, because it is neither the owner, and it
does not belong to the same group as the file, and the permissions for
everyone do not include the write permission.</p>
<p>Owners and privileged users may change the permissions of a file with
the <strong class="program">chmod</strong> shell command. The most basic structure of this command is
as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">chmod [OPTION]... MODE FILE...</span>
</pre></div>
</div>
<p>This command will change the permissions of the files mentioned in the
files parameter as indicated by the mode. There are two ways to indicate
the mode, explicitly and implicitly. The explicit mode mentions the
users affected (<code class="docutils literal notranslate"><span class="pre">u</span></code> for user, <code class="docutils literal notranslate"><span class="pre">g</span></code> for group, <code class="docutils literal notranslate"><span class="pre">o</span></code> for other, or
<code class="docutils literal notranslate"><span class="pre">a</span></code> for all) followed by an operation symbol (<code class="docutils literal notranslate"><span class="pre">+</span></code> to add, <code class="docutils literal notranslate"><span class="pre">-</span></code> to
remove, or <code class="docutils literal notranslate"><span class="pre">=</span></code> to set and remove unspecified) followed by the
previously mentioned symbols for the permissions (<code class="docutils literal notranslate"><span class="pre">r</span></code> to read, <code class="docutils literal notranslate"><span class="pre">w</span></code>
to write, and <code class="docutils literal notranslate"><span class="pre">x</span></code> to execute/search). For example if the <strong>margaret</strong>
user is going to allow everyone to read and write in her data file, not
just the owner, it may use any of the following alternatives:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">chmod g+w,o+w data</span>
<span class="go">chmod g=rw,o=rw data</span>
<span class="go">chmod =rw data</span>
</pre></div>
</div>
<p>The implicit mode can only be used to assign all permissions at once. It
assigns values to the various permissions: 4 to read, 2 to write and 1
to executer/search. Each one of these values is used at face value if we
are given permissions to other users, but they are multiplied by 10 if
we are giving permissions to the group, or by 100 if the permissions are
granted to the owner. All these values must be added and the final
number is used as the mode. For example if the margaret user is going to
grant read and write permissions to everyone we need to add 4+2 for
everyone with 40+20 for the group and 400+200 for the owner, giving a
total of 666 that can be used as the mode.</p>
<p>When creating a file (with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">open</span></code> system call) or a directory
(with <strong class="program">mkdir</strong>) we can specify their permissions with a parameter,
however, these permissions are modified by the process’s <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-file-mode-creation-mask"><span class="xref std std-term">file mode
creation mask</span></a>, also known as the <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-umask"><span class="xref std std-term">umask</span></a>. Every process inherits a
<a class="reference internal" href="../../../meta/glossary/operating-systems/#term-umask"><span class="xref std std-term">umask</span></a> from its parent process. This contains a set of permissions that
will be eliminated in every file the process creates. A typical <a class="reference internal" href="../../../meta/glossary/operating-systems/#term-umask"><span class="xref std std-term">umask</span></a>
contains the value 022, representing the write permission for group and
other users. This eliminates this permissions from all new files and
directories the process creates.</p>
</section>
<section id="process-identification">
<h2>Process Identification<a class="headerlink" href="#process-identification" title="Link to this heading"></a></h2>
<p>Processes can be recognized by their Process Identification Number,
commonly known as the <strong>PID</strong>. This is a unique positive integer number
that is assigned to the process by the kernel. The system call
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getpid</span></code> in C returns the PID associated with the calling process.
Every process is also a child of another process. For example, when a
user requests to run a program from a shell, the process generated by
that program becomes a child of the shell. A process may obtain the PID
of its parent process from the system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getppid</span></code>.</p>
<p>For greater control, related processes belong to a group with a group id. Usually, a process inherits its group and group id from its parent process. However, the parent process may decide to assign a different group to its children. This is what usually happens with commands in shells. For example, if a shell creates a pipe of commands, like <strong class="program">ls | sort</strong>, two processes are created, one for the <strong class="program">ls</strong> command and another for the <strong class="program">sort</strong> command, both with different PIDs. Because these processes are related by working in tandem, the shell makes them both part of a new group and designates the first process (<strong class="program">ls</strong>) as the group leader. Its own PID also becomes the group id.</p>
<p>In a process, a system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getpgrp</span></code> is used to obtain its own
group id. To identify the group id for any other process, one may use
the system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getpgid</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span></code>, where the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> parameter
contains the PID of the requested process.</p>
<p>A <strong>session</strong> is a set of process groups, all of which are assigned to
the same session ID. The session ID is the PID of the process that
created the session, known as the session leader. For example, when a
shell starts running, it creates a session made out of a single group
with a single process, the shell itself. This shell process is the
session leader. Every command that runs later on the shell will belong
to a group that may be different from the shell group, but they all
inherit the same session ID, the session ID of the session leader. The
system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getsid</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span></code> returns the session id of a process with the
parameter <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code>. When this system call is given a <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> of zero, it
returns the session id of the calling process.</p>
<p>The following <a class="reference internal" href="#id-c"><span class="std std-ref">program</span></a> demonstrates this concept,</p>
<div class="literal-block-wrapper docutils container" id="id-c">
<div class="code-block-caption"><span class="caption-text">id.c</span><a class="headerlink" href="#id-c" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="k">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpid</span><span class="p">();</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">ppid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getppid</span><span class="p">();</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pgrp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpgrp</span><span class="p">();</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pgid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpgid</span><span class="p">(</span><span class="n">ppid</span><span class="p">);</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getsid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">psid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getsid</span><span class="p">(</span><span class="n">ppid</span><span class="p">);</span>

<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Process ID: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Group ID:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pgrp</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Parent Process ID:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ppid</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Parent Group ID:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pgid</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Session ID:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sid</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%-30s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;My Parent Session ID:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">psid</span><span class="p">);</span>

<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Output of `ps&#39;:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="nf">fflush</span><span class="p">(</span><span class="nv">stdout</span><span class="p">);</span>

<span class="w">  </span><span class="nf">system</span><span class="p">(</span><span class="s">&quot;ps --forest -o pid,pgrp,ppid,pgid,sid,cmd&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text"><strong class="program">id</strong> output</span><a class="headerlink" href="#id1" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">My Process ID:                 66673</span>
<span class="go">My Group ID:                   66673</span>
<span class="go">My Parent Process ID:          56072</span>
<span class="go">My Parent Group ID:            56072</span>
<span class="go">My Session ID:                 56072</span>
<span class="go">My Parent Session ID:          56072</span>

<span class="go">Output of `ps&#39;:</span>

<span class="go">    PID    PGRP    PPID    PGID     SID CMD</span>
<span class="go">  56072   56072   56058   56072   56072 /bin/bash --posix</span>
<span class="go">  66673   66673   56072   66673   56072  \_ ./id</span>
<span class="go">  66674   66673   66673   66673   56072      \_ ps --forest -o pid,pgrp,ppid,pgid,sid,cmd</span>
</pre></div>
</div>
</div>
<p>The output above also shows how the command <strong class="command">ps</strong> can be used to display the ID of processes currently running by the shell. Notice that the process called <strong class="command">id</strong> is made asleep in the background so the <strong class="command">ps</strong> command can find it and display it. To view all processes in the system the <strong class="command">ps -A</strong> command can be used.</p>
<p>A session also has a <strong>controlling terminal</strong> that is determined when
the session is created. The terminal is where user interaction happens,
where the user may enter commands through the standard input and see
results from the standard output (if not redirected). A session may have
control of just one terminal and a terminal may be controlled just by
one session leader. Every process in the session is associated to the
terminal, but only one process group is considered to be on the
<strong>foreground</strong>. This means that this process group is the only one that
is able to read messages from the standard input, namely to receive
commands from the terminal. All other groups belonging to the same
session are considered to be on the <strong>background</strong>.</p>
<p>The system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">setpgid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">pgid</span><span class="p">)</span></code> is used to change the group id of
the process with the parameter <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> to a value of <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pgid</span></code>. This
system call has the following characteristics:</p>
<ul class="simple">
<li><p>If <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> is zero, the change happens to the calling process.</p></li>
<li><p>If <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pgid</span></code> is zero, the group id of the process with the parameter
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> is changed to <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> and becomes that group leader.</p></li>
<li><p>The parameter <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> may only refer to the calling process itself or
one of its children and it cannot be a session leader.</p></li>
<li><p>The calling process, as well as both processes on the parameters
(<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pid</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pgid</span></code>) must belong to the same session.</p></li>
</ul>
<p>Similarly, a session id for a process can also be changed with the
system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">setsid</span></code>. A process other than the session leader can
make this call that creates a separate session with a single group. The
PID of this calling process becomes the group id and session id of the
new group and the new session. However, this new session will have no
controlling terminal.</p>
<p>Every process is also running at the bequest of a user. All users are
assigned a <strong>user ID</strong>, or <strong>UID</strong>. A process may request the identity
of its user with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getuid</span></code> system call.The user must have the
right to run the process either because it is the owner, or because it
belongs to a group with the right to run that process or because that
process is available for everyone to run.</p>
<p>On occasions, the owner of a program may grant its right to run it as a
process to another user which cannot. To do that, the program must set
its <strong>set-user-id</strong> and/or <strong>set-group-id</strong> bits. The following figure
shows how this can be done and the effect it causes in the program.
Notice in the figure how the privileges for <code class="file docutils literal notranslate"><span class="pre">identify</span></code> are
changed</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $ls -l identify</span>
<span class="go">-rwxr-xr-x. 1 master master 17824 Jun 14 21:46 identify</span>
<span class="go">master $chmod u+s identify</span>
<span class="go">master $chmod g+s identify</span>
<span class="go">master $ls -l identify</span>
<span class="go">-rwsr-sr-x. 1 master master 17824 Jun 14 21:46 identify</span>
</pre></div>
</div>
<p>If a user other than <strong>master</strong>, its owner, may run <strong class="program">identify</strong> as a
process, it will run as if it were the owner. To do that, the kernel
uses what is called the <strong>effective user ID</strong>, or <strong>EUID</strong> and its
associated <strong>effective group ID</strong>, or <strong>EGID</strong> instead of its own uid
and gid. A process may identify its EUID and EGID with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">geteuid</span></code>
and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getegid</span></code> system calls, respectively. To make multiple uses of
this program, the EUID and EGID are stored as <strong>set-user-ID</strong>, or
<strong>SUID</strong>, and the <strong>set-group-ID</strong>, or <strong>SGID</strong>.</p>
<p>We invite you to read more about credentials for process in the
credentials page of the man pages.</p>
</section>
<section id="the-init-process">
<h2>The init Process<a class="headerlink" href="#the-init-process" title="Link to this heading"></a></h2>
<p>We mentioned that every process is a child of another process, for this
to be possible, there must be a process that was the first. This process
is known as the <strong class="program">init</strong> process and it is created by the kernel when
the operating system is at booting stage. This process is the first one
to appear and it is the last one to go. It remains active from start-up
to system shutdown. It cannot be destroyed, not even by a superuser,
because it keeps control of other important processes that allow the
correct running of the operating system. In particular it is in charge
of taking care of “orphaned” processes as we will later see. Every
process in the system is a descendant of init. The process ID for the
<strong class="program">init</strong> process is the number 1 and it has the highest privileges, as
if it were run by the superuser.</p>
</section>
<section id="process-creation">
<h2>Process Creation<a class="headerlink" href="#process-creation" title="Link to this heading"></a></h2>
<p>When a program is to be run, the operating system allocates various
portions of memory (RAM) to the process. They constitute the <strong>virtual
memory address space</strong> for the process. The amount of memory to be
assigned varies from machine to machine and from program to program, and
it solely depends on what the operating system decides. For this
discussion, let’s assume that a process is assigned 64Kb of memory. Its
address space begins with memory at position zero (0x0000 in
hexadecimal) and its last address is one position before 64Kb (address
0xFFFF). Certain portions at the beginning and at the end of this
address space are reserved by the operating system for process
management and to store kernel references that will be used by the
process. For this reason, let’s also assume that this leaves us with a
remaining address space for the process beginning at 16Kb (address
0x4000) and ending one position before 48Kb (address 0xBFFF).</p>
<p>The remaining address space is further divided in <strong>segments</strong>. Each
segment is assigned a different function and contains specific
information for the process. On this first segment, known as the
<strong>text</strong>, the operating system loads all the instructions of the
compiled file (the program code). These are followed by all global and
static data that are initialized by the program, and after them all
global and static data that is not initialized. In our example, the text
will begin at 16Kb (address 0x4000) and will continue until all code and
global and static data is placed. The actual addresses where the program
code, the initialized data, and then uninitialized data end, are all
stored in CPU registers to inform the running of the process.</p>
<p>A second segment, the <strong>stack,</strong> begins at the other end of the address
space (address 0xBFFF in our example), and it actually grows backwards
towards the beginning of the address space. The stack is used to keep
track of the functions the process calls. A CPU register (labeled as
%rsp) holds the value of the memory address at the end of the stack.
This address is known as the <strong>top of the stack</strong>. Every time a function
is called, a new <strong>stack frame</strong> is added after the top of the stack.
The stack frame contains information relevant to the function call and
includes values for the parameters passed to the function call as well
as places for the values of all the variables that are local to the
function. Once the stack frame is added, the top of the stack is updated
to point to the end of this new frame. When the function finishes
calculations, its return value is stored in a CPU register to be sent to
the calling function, the memory allocated to the stack frame is
released, and the top of the stack is moved back to point at the end of
the previous function call.</p>
<p>The third and last assigned segment is the <strong>heap</strong>. This usually lies
right after the memory assigned for the uninitialized data and grows in
opposite direction to the stack. The heap provides memory for all
variables that are dynamically allocated when the process runs. The end
of the heap is known as the <strong>program break</strong>, and the kernel may change
its location to make it grow or shrink, based on the need and requests
from the process.</p>
<p>The following figure shows an example of the placement of these segments
in the virtual memory address space for a process:</p>
<a class=""
               data-lightbox="group-f5774776-20f9-4615-b93d-4b86cc28de13"
               href="../../../_images/image21.png"
               title=""
               data-title=""
               
               ><img src="../../../_images/image21.png"
                     class=""
                     width="30%"
                     height="auto"
                     alt=""/>
                </a><p>It is important to realize that this diagram shows memory from the point
of view of the process, and likely, it will not represent the actual
memory arrangement of hardware that the kernel has at its disposal. For
example, the kernel will not grant access to the physical address 0x0000
to any process. This is reserved for the operating system. Also, the
process may assume that all its segments are placed continuously in
memory, when in fact the kernel usually makes allocations in
non-contiguous areas. However, the process does not need to worry about
any misalignment, because a big part of the kernel’s job is to maintain
the illusion of a unified memory space for every process.</p>
<p>Once these segments are allocated, the operating system makes some other
initializations. Every process is associated with three standard files:
standard input, standard output, and standard error. The standard input
file is the place from where the process will get external input,
usually the keyboard. The standard output is the place from where all
textual output from the process will be written. This is generally the
screen or terminal from where the process is launched. Finally, the
standard error is the place where all errors encountered by the process
while running are to be reported. Most of the time this is also the same
screen or terminal used for standard output, but there are other
options, like sending it to a file in disk. The operating system will
treat each one of these standard files like any other file in the system
and will set file descriptors for each one of them. If there is
redirection of these files, the operating system will modify the
appropriate file descriptor to point to the requested device or file.</p>
<p>Finally, the operating system must initialize a CPU register with the
address of the first executable sentence from the program. This register
is known as the <strong>Instruction Pointer</strong> or <strong>IP</strong> (also known as the
<strong>program counter</strong> or <strong>PC</strong>).</p>
<p>As an example of how the kernel assign a program to various segments in
the process’ memory space, consider the <a class="reference internal" href="#compound-c"><span class="std std-ref">following C program</span></a> that creates
a small table of compound interest:</p>
<div class="literal-block-wrapper docutils container" id="compound-c">
<div class="code-block-caption"><span class="caption-text">compound.c</span><a class="headerlink" href="#compound-c" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Program: compound.c</span>
<span class="cm"> * Version: 1.0</span>
<span class="cm"> * Author: Guillermo Tonsmann Ph.D. */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">username</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Name of the User &lt;Uninitialized data&gt; */</span>
<span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Table of Compounded Amounts&quot;</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Title to be Displayed</span>
<span class="cm">                                                  &lt;Initialized Data&gt; */</span>

<span class="cm">/** Evaluate compounded interest over a number of periods</span>
<span class="cm"> * Arguments:  &lt;on Stack&gt;</span>
<span class="cm"> *   array: Pointer to an array of p+1 floats to be filled with compounded</span>
<span class="cm"> *          amounts</span>
<span class="cm"> *   a    : initial amount to be compounded.</span>
<span class="cm"> *   r    : interest rate as a fraction</span>
<span class="cm"> *   p    : number of periods to be compounded (== size_of_array-1)</span>
<span class="cm"> */</span>
<span class="k">float</span>
<span class="n">compound</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="cm">/* First position of array contains the initial amount to be</span>
<span class="cm">                 compounded */</span>

<span class="w">  </span><span class="cm">/* Evaluating the compound interest at each period and placing it in the array</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">));</span><span class="w"> </span><span class="cm">/* &lt;Value returned in a register&gt; */</span>
<span class="p">}</span>

<span class="cm">/* Display a table of compounded amounts</span>
<span class="cm"> * Arguments:  &lt;on Stack&gt;</span>
<span class="cm"> *   array: Pointer to an array of p+1 compounded amounts</span>
<span class="cm"> *   p    : number of periods to be compounded (== size_of_array-1) */</span>
<span class="kt">void</span>
<span class="n">display</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="p">);</span><span class="w"> </span><span class="cm">/* &lt;from Initialized Data&gt;  */</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Created by: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">username</span><span class="p">);</span>

<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%15s %15s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Amount&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; After Period&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Table headings */</span>
<span class="w">  </span><span class="cm">/* Printing each line of the table */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%15.2f %8d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Nothing to return */</span>
<span class="p">}</span>

<span class="cm">/** Gets data from argv, generates an array for compound values</span>
<span class="cm"> * and ask to be populated and displayed */</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[],</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">environ</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Static Variables */</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">float</span><span class="w"> </span><span class="n">amount</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Initial amount to be compounded. No default.</span>
<span class="cm">                               &lt;Uninitialized Data&gt; */</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">float</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Interest rate as a fraction. Default: 1% as 0.01</span>
<span class="cm">                             &lt; Initialized Data&gt; */</span>

<span class="w">  </span><span class="cm">/* Local variables &lt;on Stack&gt; */</span>
<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">periods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Periods to be compounded. Default: 5 periods */</span>
<span class="w">  </span><span class="k">float</span><span class="w"> </span><span class="o">*</span><span class="n">compound_array</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Array of compounded amounts (to be created) */</span>
<span class="w">  </span><span class="k">float</span><span class="w"> </span><span class="n">interest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Accumulated interest over all periods */</span>

<span class="w">  </span><span class="n">username</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Getting a variable from the Environment</span>
<span class="cm">                                    Array &lt;On Stack&gt; */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">username</span><span class="p">)</span><span class="w"> </span><span class="n">username</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;(Unknown)&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="cm">/* Reading and validating parameters from argv &lt;on Stack&gt; */</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nv">argc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span>
<span class="w">      </span><span class="n">periods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">atoi</span><span class="p">(</span><span class="nv">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span>
<span class="w">      </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">atof</span><span class="p">(</span><span class="nv">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">100.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span>
<span class="w">      </span><span class="n">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">atof</span><span class="p">(</span><span class="nv">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Invalid number of parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s compound amount rate periods</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">      </span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="cm">/* Validating periods */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">periods</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Periods should be integer with value greater than 1 </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="cm">/* program returns with errors */</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="cm">/* Creation of a dynamic array for the list of compounded amounts &lt;on Heap&gt; */</span>
<span class="w">  </span><span class="n">compound_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="o">*</span><span class="n">compound_array</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">periods</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">compound_array</span><span class="p">)</span><span class="w"> </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Call to evaluate compounded amounts. Total interest earned is returned. */</span>
<span class="w">  </span><span class="n">interest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compound</span><span class="p">(</span><span class="n">compound_array</span><span class="p">,</span><span class="w"> </span><span class="n">amount</span><span class="p">,</span><span class="w"> </span><span class="n">rate</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Call to display a table of compounded amounts. */</span>
<span class="w">  </span><span class="n">display</span><span class="p">(</span><span class="n">compound_array</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Additional information added to the table.  */</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Accumulated Interests:%.2f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">interest</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* program returns successfully */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>After compilation, the program can be executed with parameters 1000, 2,
and 7, corresponding to an amount of $1000.00 to be compounded at 2% per
period during 7 periods. This produces the outcome shown in Figure 5.3:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">	Table of Compounded Amounts</span>
<span class="go">		Created by: ryan</span>
<span class="go">         Amount    After Period</span>
<span class="go">        1000.00        0</span>
<span class="go">        1020.00        1</span>
<span class="go">        1040.40        2</span>
<span class="go">        1061.21        3</span>
<span class="go">        1082.43        4</span>
<span class="go">        1104.08        5</span>
<span class="go">        1126.16        6</span>
<span class="go">        1148.69        7</span>
<span class="go">	Accumulated Interests:148.69</span>
</pre></div>
</div>
<p>When the operating system receives the request to run the program for
compound interest, it will initially load the various segments as shown
in Figure 5.4. Notice that the values of global variable <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">title</span></code> and
the static variable <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rate</span></code> are placed in the initialized data section
of the text segment, while some memory space is left for the global
variable <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">username</span></code> and the static variable <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">amount</span></code> that will be
filled with values when the program runs. The first stack frame to be
loaded on the stack segment contains information for the running of the
first function in any C program, <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">main</span></code>. The stack frame is filled in
the opposite direction than the text segment. At the top of the stack,
we found the value of <code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">argc</span></code>, that is the number of arguments passed
by the shell to the program (4 in this case). This is followed in order
by the arguments from <code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">argv</span></code> and the environment variables from
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">env</span></code>, also received from the shell. Given that these values may have
different sizes, rather than placing them in that position, they are
actually located at the end of the stack frame, and only pointers to
their actual location are stored at the beginning of the stack. The
stack frame also includes memory to store the contents of the local
variables from the main function. The stack frame may contain some
additional memory assigned as padding; because they should be aligned at
specific word sizes (16 or 32 bytes depending on the architecture).
Since no dynamic allocation was performed at this stage, the heap may
not have any actual memory associated with it. Nevertheless, a program
break will be already set, probably at the end of the text segment.</p>
<a class=""
               data-lightbox="group-f48a26ff-00a8-44b2-ae90-5ea25408e17e"
               href="../../../_images/image31.png"
               title=""
               data-title=""
               
               ><img src="../../../_images/image31.png"
                     class=""
                     width="30%"
                     height="auto"
                     alt=""/>
                </a><div class="line-block">
<div class="line">By the time the program is running and calls the compound function,
the segments may appear as described by Figure 5.5. By then, the main
function has requested memory for the contents of the compound_array.
The operating system will grant this request on the heap, by
increasing the program break to a size that provides enough space.
However, the operating system may decide to provide more than the
requested space, based on its own policies. The compound function will
add a new stack frame to the stack segment. This stack frame will
contain enough memory to hold all the parameters for the function and
its local variables. Some padding memory may also be added. The top of
the stack is moved accordingly to the end of this stack frame. When
the function ends running, the value returned by the function will be
placed on a CPU register for the calling function to take and the
allocated memory is released by moving the top of the stack back to
its previous value at the end of the stack frame for the main
function.</div>
<div class="line">.. image:: images/image4.png</div>
</div>
<p>When the program calls the display function, a new stack frame is added
on top of the stack segment. This new frame contains memory to hold all
its parameters, its local variables, and padding memory if required.
Once again, the top of the stack is moved to the end of this stack
frame. This function uses the file descriptor for the standard output to
display the program’s results. When it finishes it does not return any
value. The top of the stack is moved back to the end of the stack frame
for the main function.</p>
<a class=""
               data-lightbox="group-e74d69d7-9168-469a-8476-5c473c06fd11"
               href="../../../_images/image51.png"
               title=""
               data-title=""
               
               ><img src="../../../_images/image51.png"
                     class=""
                     width="30%"
                     height="auto"
                     alt=""/>
                </a></section>
<section id="process-lifecycle">
<h2>Process Lifecycle<a class="headerlink" href="#process-lifecycle" title="Link to this heading"></a></h2>
<p>Once a process is loaded in memory we say that the process is in a
<strong>ready state</strong>. It is ready for its instructions to be run by the CPU.
At any given time there could be many processes in ready state trying to
access the CPU. All these processes constitute a <strong>ready queue</strong> from
which the kernel decides which process to run next. If the kernel
decides to run a process from this queue, it updates the <strong>CPU
context</strong>. This is the set of CPU registers that contain pointers to the
locations where the process segments for that process are loaded. These
include the values for program break, base of the stack, bottom of the
stack, and instruction pointer. The kernel updates the CPU context with
the appropriate values for the process to be run. The kernel then
switches to user mode and allows the process to take charge of the
computer to perform its instructions. This is a second state of the
process known as the <strong>running state</strong>. The process will remain in this
stage until one of the following events happens:</p>
<ol class="arabic simple">
<li><p>The process completes all its instructions and requests the kernel to
terminate it.</p></li>
<li><p>The process does not complete all its instructions, but it is
terminated by the kernel due to an irrecoverable error while running.</p></li>
<li><p>The process does not complete all its instructions, but it is
terminated by the kernel because a predetermined amount of time has
passed, and the kernel wants to give access to the CPU to other
processes in the ready queue.</p></li>
<li><p>The process requires some resource (memory, reading of a file, or
access to a peripheral, for example), and it is making a request to
the kernel for that resource.</p></li>
</ol>
<p>In all these cases, the process stops operations and the kernel takes
control in kernel mode. In cases 1 and 2, where the process will no
longer be active, it is terminated by the kernel, and all the resources
that were allocated to that process are released at the kernel’s
disposal. In case 3, when the allotted time for running has expired, the
kernel places the process back into the ready queue, to wait for a new
time slot. In case 4, where the process requires a resource, if the
kernel can satisfy that request quickly, it will grant it, and let the
process resume operations again in user mode. If on the other hand, the
process must wait for some resource in a queue, the kernel changes the
state of the process to a <strong>waiting state</strong> until it can get hold of the
resource. When this happens, the kernel moves the process back to the
ready queue to wait for a new time slot, just like in case 3.</p>
<p>In both cases, 3 and 4, before the process changes state, all registers
in the CPU context are stored. These stored registers will be used later
to restore execution of the program when the process is sent back to the
running state. Therefore, every time that the kernel changes the process
to be running in the CPU, it saves CPU context of the old process and
copies the recorded CPU context of the new one (if it exists) on the
actual CPU registers. This activity is called <strong>context switching</strong>,</p>
<p>The figure below shows the flow of a process along its possible states:</p>
<a class=""
               data-lightbox="group-ee68f2d8-9039-4a1a-8d5b-a961c9534c91"
               href="../../../_images/image61.png"
               title=""
               data-title=""
               
               ><img src="../../../_images/image61.png"
                     class=""
                     width="30%"
                     height="auto"
                     alt=""/>
                </a></section>
<section id="process-termination">
<h2>Process Termination<a class="headerlink" href="#process-termination" title="Link to this heading"></a></h2>
<p>There are two ways in which a process is terminated. In the first one,
the process itself requests its termination to the kernel by calling the
system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">_exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span></code>. The underscore is part of the name of
the system call, and the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">status</span></code> is an integer value, usually between 0
and 128, known as the exit code. Processes that end successfully usually
return with an exit code of zero. The process may use a value different
than zero for the exit code to indicate some possible error that was
encountered while running. Users and processes expecting the conclusion
of that process may review this value to determine further actions.
Within a shell, the exit code of the latest terminated process is stored
in the environment variable <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">$</span><span class="o">?</span></code>. The second way in which a process
may be terminated is by using signals.</p>
</section>
<section id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Link to this heading"></a></h2>
<p><strong>Signals</strong> are messages sent to processes to notify them of certain
events. These could be sent between processes, but the most common
signals are sent by the kernel. The kernel will send a signal to a
process if there is a hardware issue, like an attempt to divide by zero,
or to access a non-existent address in memory. The kernel will also send
signals to let processes know of any condition that affects them, like
the reading of a file being completed, or a terminal being closed; more
importantly, if the allotted CPU time for a process has concluded and
needs to be terminated or sent to a waiting state. The kernel may also
notify the process with a signal if the user pressed specific
combinations of keys, like <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd> or <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">\</kbd>, that have a special
meaning for processes as we will see below.</p>
<p>Signals are codified with integer numbers greater than 1. The kernel
uses the first 31 signals for specific well known messages. They are
known as the <strong>standard signals</strong>. Each of these standard signals has a
name that begins with the prefix <code class="docutils literal notranslate"><span class="pre">SIG</span></code> followed by three or four other
letters. All of these macros are defined in the <code class="file docutils literal notranslate"><span class="pre">signal.h</span></code> header.</p>
<p>When an event <strong>generates</strong> a signal, it is <strong>delivered</strong> to the process, if the process is currently running in the CPU, it receives the signal the next time it returns from kernel mode–e.g. returning from a system call, generating a page fault, being scheduled to run, etc. In the time between the generation and the actual delivery of the signal we said that the signal is <strong>pending</strong>. Once the signal is delivered, it normally elicits a <strong>default action</strong> from the process. These default actions could be one of following five:</p>
<dl class="simple">
<dt>Ignore</dt><dd><p>Ignore the signal.</p>
</dd>
<dt>Terminate</dt><dd><p>Abnormal termination of the process</p>
</dd>
<dt>Abort</dt><dd><p>Abnormal termination of the process with additional actions (core dump).</p>
</dd>
<dt>Stop</dt><dd><p>Stop the process.</p>
</dd>
<dt>Continue</dt><dd><p>Continue the process, if it is stopped; otherwise ignore the signal.</p>
</dd>
</dl>
<p>The list of which signal corresponds to which default action can be found in <em class="manpage">signal.h</em>.</p>
<p>The <a class="reference internal" href="#run-forever-c"><span class="std std-ref">listing</span></a> below presents a program that simply busy-waits. We can use this program to review
the four signals above. When the
program runs in the foreground, we can terminate it by pressing either
<kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">c</kbd> or <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">\</kbd>. In the first case the keystrokes makes the
terminal send a <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> signal. When the program receives it, the process
terminates. The second case is similar, but the signal sent is <code class="docutils literal notranslate"><span class="pre">SIGQUIT</span></code>,
and its default action is to terminate, but creating a core dump. We see the same process running, but this time we use the
ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) to send it to the background. To terminate this process,
we need to use the system call <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">kill</span></code>. Despite its name, the main
purpose of this system call is to send signals to processes. We can use
the shell utility <strong class="program">kill</strong></p>
<div class="literal-block-wrapper docutils container" id="run-forever-c">
<div class="code-block-caption"><span class="caption-text">run_forever.c</span><a class="headerlink" href="#run-forever-c" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(;;);</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./run_forever
<span class="go">^C</span>

<span class="gp">$ </span>./run_forever
<span class="go">^\Quit (core dumped)</span>

<span class="gp">$ </span>run_forever<span class="w"> </span><span class="p">&amp;</span>
<span class="go">[1] 4823</span>
<span class="gp">$ </span>ps
<span class="go">   PID TTY         TIME CMD</span>
<span class="go">   2605 pts/0    00:00:00 bash</span>
<span class="go">   4823 pts/0    00:00:03 run_forever</span>
<span class="go">   4828 pts/0    00:00:00 ps</span>
<span class="gp">$ </span><span class="nb">kill</span><span class="w"> </span>-15<span class="w"> </span><span class="m">4823</span>
<span class="go">[1]+  Terminated                    run_forever</span>
<span class="gp">$ </span>ps
<span class="go">   PID TTY         TIME CMD</span>
<span class="go">   2605 pts/0    00:00:00 bash</span>
<span class="go">   4837 pts/0    00:00:00 ps</span>
</pre></div>
</div>
<p>Notice that when a shell process has background processes, it assigns
them a <strong>job control number</strong> or <strong>JobID</strong>. In the figure above, that
number is 1 surrounded by square brackets [1]. Use that number to refer
to this process. We can review all jobIDs with the bash command
<strong class="program">jobs</strong>. The <strong class="program">fg</strong> and <strong class="program">bg</strong> commands can be used to move jobs
to/from foreground or background respectively. These jobs also receive
signals with the <strong class="program">kill</strong> command. The following output demonstrates <a class="reference internal" href="#run-forever-c"><span class="std std-ref">run_forever.c</span></a> run three times on the shell and being handled by
the these various job control commands:</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">Running run_forever in the background three times</span><a class="headerlink" href="#id2" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $run_forever &amp;</span>
<span class="go">[1] 3300</span>
<span class="go">master $run_forever &amp;</span>
<span class="go">[2] 3394</span>
<span class="go">master $run_forever &amp;</span>
<span class="go">[3] 3417</span>
<span class="go">master $ps</span>
<span class="go"> PID TTY TIME CMD</span>
<span class="go"> 2647 pts/0 00:00:00 bash</span>
<span class="go"> 3300 pts/0 00:00:04 run_forever</span>
<span class="go"> 3394 pts/0 00:00:02 run_forever</span>
<span class="go"> 3417 pts/0 00:00:01 run_forever</span>
<span class="go"> 3399 pts/0 00:00:00 ps</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">Running run_forever in the background three times</span><a class="headerlink" href="#id3" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $run_forever &amp;</span>
<span class="go">[1] 3300</span>
<span class="go">master $run_forever &amp;</span>
<span class="go">[2] 3394</span>
<span class="go">master $run_forever &amp;</span>
<span class="go">[3] 3417</span>
<span class="go">master $ps</span>
<span class="go"> PID TTY TIME CMD</span>
<span class="go"> 2647 pts/0 00:00:00 bash</span>
<span class="go"> 3300 pts/0 00:00:04 run_forever</span>
<span class="go"> 3394 pts/0 00:00:02 run_forever</span>
<span class="go"> 3417 pts/0 00:00:01 run_forever</span>
<span class="go"> 3399 pts/0 00:00:00 ps</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">Sending job [2] to the foreground &amp; Stopping it with <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">Z</kbd>.</span><a class="headerlink" href="#id4" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $fg %2</span>
<span class="go">run_forever</span>
<span class="go">^Z</span>
<span class="go">[2]+ Stopped run_forever</span>
<span class="go">master $jobs</span>
<span class="go">[1] Running run_forever &amp;</span>
<span class="go">[2]+ Stopped run_forever</span>
<span class="go">[3]- Running run_forever &amp;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">Sending job [2] to the background again</span><a class="headerlink" href="#id5" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $bg %2</span>
<span class="go">[2]+ run_forever &amp;</span>
<span class="go">master $jobs</span>
<span class="go">[1] Running run_forever &amp;</span>
<span class="go">[2]- Running run_forever &amp;</span>
<span class="go">[3]+ Running run_forever &amp;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Stopping job [3] with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGSTOP</span></code> signal</span><a class="headerlink" href="#id6" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $kill -STOP %3</span>

<span class="go">[3]+ Stopped run_forever</span>
<span class="go">master $jobs</span>
<span class="go">[1] Running run_forever &amp;</span>
<span class="go">[2]- Running run_forever &amp;</span>
<span class="go">[3]+ Stopped run_forever</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Stopping job [3] with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGSTOP</span></code> signal</span><a class="headerlink" href="#id7" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $kill -STOP %3</span>

<span class="go">[3]+ Stopped run_forever</span>
<span class="go">master $jobs</span>
<span class="go">[1] Running run_forever &amp;</span>
<span class="go">[2]- Running run_forever &amp;</span>
<span class="go">[3]+ Stopped run_forever</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">Terminating job [3] with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGTERM</span></code> signal</span><a class="headerlink" href="#id8" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $kill -TERM %3</span>
<span class="go">[3]+ Terminated run_forever</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">Terminating job [2] with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> signal</span><a class="headerlink" href="#id9" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $kill -INT %2</span>
<span class="go">[2]+ Interrupt run_forever</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">Terminating job [1] with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGKILL</span></code> signal</span><a class="headerlink" href="#id10" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">master $kill -KILL %1</span>
<span class="go">[1]+ Killed run_forever</span>
<span class="go">master $jobs</span>
<span class="go">master $</span>
</pre></div>
</div>
</div>
<p>In general, a process may decide not to take the default action
requested by a signal, instead it may allow for the signal to be
ignored, or it may decide to do something else when it receives it. A
process changing its default action under a signal is said to be
<strong>changing its signal disposition</strong>. This can be done if the process
invokes the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code> system call from <code class="file docutils literal notranslate"><span class="pre">signal.h</span></code>
that has the following prototype:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="kt">sighandler_t</span><span class="w"> </span><span class="nf">signal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>This prototype can be a bit confusing to read, made clearer by first defining a <code class="code highlight c c99 docutils literal highlight-c99"><span class="kt">sighandler_t</span></code> type,</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">sighandler_t</span><span class="w"> </span><span class="nf">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">sighandler_t</span><span class="w"> </span><span class="nf">signal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="kt">sighandler_t</span><span class="w"> </span><span class="n">handler</span><span class="p">);</span>
</pre></div>
</div>
<p>The parameters for the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code> system call are the signal number to
which the process wants to change its disposition and a pointer to a
<strong>handler function</strong>. The process must have access to the handler
function and the handler function must receive an integer and return
void. The handler function will contain the actions the process wants to
be executed when the signal arrives. A common use of the handler
function is to tidy up before the process is terminated, by returning
resources, like memory previously requested with malloc, or close files,
before calling the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">exit</span></code> system call itself.</p>
<p>The following listing shows the program
<span class="xref std std-ref">signal.c</span> that changes the signal disposition for the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code>, <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGQUIT</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGTERM</span></code> signals using the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code> system call to the handler function
named <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sig_handler</span></code> that stores the signal number that was received. We will discuss the purpose of <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigprocmask</span></code> and the <code class="code highlight c c99 docutils literal highlight-c99"><span class="kt">sigset_t</span></code> variables in short order.</p>
<div class="literal-block-wrapper docutils container" id="signal">
<div class="code-block-caption"><span class="caption-text">signal.c</span><a class="headerlink" href="#signal" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#define _POSIX_C_SOURCE 200809L</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;signal.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="cm">/* sig_atomic_t is an async-signal safe data type */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">sig_atomic_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Signal sets for blocking/unblocking signals. */</span>
<span class="kt">sigset_t</span><span class="w"> </span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="n">oldsigset</span><span class="p">;</span>

<span class="cm">/** Record received signal handler */</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span>
<span class="n">sig_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">errno_sav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">errno</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Cache errno */</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Reinstall signal handler */</span>
<span class="w">  </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errno_sav</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Restore errno */</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Hold pending signals until their handlers are installed */</span>
<span class="w">  </span><span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">oldsigset</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Install signal handlers SIGINT, SIGQUIT and SIGTERM */</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGQUIT</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGTSTP</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>

<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">last_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signo</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Unblock signals and sleep until a signal is caught */</span>
<span class="w">    </span><span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsigset</span><span class="p">);</span>
<span class="w">    </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Signal Received: %d (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">signo</span><span class="p">,</span><span class="w"> </span><span class="nf">strsignal</span><span class="p">(</span><span class="n">signo</span><span class="p">));</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">signo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">SIGINT</span><span class="o">:</span>
<span class="w">        </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;I was, in fact, interrupted!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">SIGQUIT</span><span class="o">:</span>
<span class="w">        </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Ok, time to exit!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">SIGTSTP</span><span class="o">:</span>
<span class="w">        </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Understood--powering down!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="nf">fflush</span><span class="p">(</span><span class="nv">stdout</span><span class="p">);</span>
<span class="w">        </span><span class="nf">raise</span><span class="p">(</span><span class="no">SIGSTOP</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">last_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signo</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./signal
<span class="go">^C	Signal Received: 2 (&quot;Interrupt&quot;)</span>
<span class="go">I was, in fact, interrupted!</span>
<span class="go">^Z	Signal Received: 20 (&quot;Stopped&quot;)</span>
<span class="go">Understood--powering down!</span>
<span class="go">[2]+  Stopped                 ./signal</span>

<span class="gp">$ </span><span class="nb">fg</span>
<span class="go">./signal</span>
<span class="go">^\	Signal Received: 3 (&quot;Quit&quot;)</span>
<span class="go">Ok, time to exit!</span>

<span class="gp">$</span>
</pre></div>
</div>
<p>Although by the description of the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code> system call, it appears to be returning void, it is in fact returning a pointer to the previous disposition the signal had. This is handy when we want to preserve the previous handling conditions to be restored at a later point in time. The following <a class="reference internal" href="#swapping-handlers"><span class="std std-ref">listing</span></a> demonstrates a program that alternates between the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sig_handler</span></code> handler function we previously saw, and the default handling for the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> signal (<kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd>). When the program invokes the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code> system call to set the disposition to <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sig_handler</span></code> for the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> signal, it returns the default handling of this signal that is stored in a pointer named <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">old_sig_handler</span></code>, with the same signature as the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sig_handler</span></code> function. The <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">old_sig_handler</span></code> function is later restored with another call to <code class="code highlight c c99 docutils literal highlight-c99"><span class="nf">signal</span></code>. In the output, we see that while <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sig_handler</span></code> is in use, the process cannot be terminated with <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd>, but this behavior stops when the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">old_sig_handler</span></code> is in charge.</p>
<div class="literal-block-wrapper docutils container" id="swapping-handlers">
<div class="code-block-caption"><span class="caption-text">swapping_handlers.c</span><a class="headerlink" href="#swapping-handlers" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#define _POSIX_C_SOURCE 200809L</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;signal.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="cm">/* sig_atomic_t is an async-signal safe data type */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">sig_atomic_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Signal sets for blocking/unblocking signals. */</span>
<span class="kt">sigset_t</span><span class="w"> </span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="n">oldsigset</span><span class="p">;</span>

<span class="cm">/* Pointer to a signal handler function */</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">old_sig_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/** Record received signal handler */</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span>
<span class="n">sig_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">errno_sav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">errno</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Cache errno */</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">old_sig_handler</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Revert signal handler */</span>
<span class="w">  </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errno_sav</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Restore errno */</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Hold pending signals until their handlers are installed */</span>
<span class="w">  </span><span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">oldsigset</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Install signal handler for SIGINT */</span>
<span class="w">  </span><span class="n">old_sig_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>
<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;signal handler for SIGINT is active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="nf">fflush</span><span class="p">(</span><span class="nv">stdout</span><span class="p">);</span>

<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">last_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signo</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Unblock signals and sleep until a signal is caught */</span>
<span class="w">    </span><span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsigset</span><span class="p">);</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Signal Received: %d (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">signo</span><span class="p">,</span><span class="w"> </span><span class="nf">strsignal</span><span class="p">(</span><span class="n">signo</span><span class="p">));</span>
<span class="w">    </span><span class="nf">fflush</span><span class="p">(</span><span class="nv">stdout</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">swapping_handlers output</span><a class="headerlink" href="#id11" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./swapping_handlers
<span class="go">signal handler for SIGINT is active</span>
<span class="go">^C	Signal Received: 2 (&quot;Interrupt&quot;)</span>
<span class="go">^C</span>

<span class="gp">$</span>
</pre></div>
</div>
</div>
<p>A process may also block the delivery of a signal. This will do nothing to the signal, but it may allow the process to complete some activity that must be done uninterrupted by the disposition of the signal. To block a signal, the process keeps track of a <strong>blocked set</strong>, this a set of signals with data type <code class="code highlight c c99 docutils literal highlight-c99"><span class="kt">sigset_t</span></code> that collects the numbers of all signals to be blocked by the process. A signal will remain blocked until it is released, at which point is delivered.</p>
<p>The blocked set must be initialized as empty with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigemptyset</span></code> system call. To which we must add all the signals we wish to block, one by one, with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigaddset</span></code> system call. We will also need the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigprocmask</span></code> system call to manage the blocked set. The prototypes for these system calls are:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">int</span><span class="w"> </span><span class="n">sigemptyset</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="k">int</span><span class="w"> </span><span class="n">sigaddset</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">);</span>
<span class="k">int</span><span class="w"> </span><span class="n">sigprocmask</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">how</span><span class="p">,</span><span class="w"> </span><span class="kt">sigset_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">oldset</span><span class="p">);</span>
</pre></div>
</div>
<p>The following <a class="reference internal" href="#blocking-signals"><span class="std std-ref">listing</span></a> shows a program that alternates between blocking and unblocking signals,</p>
<div class="literal-block-wrapper docutils container" id="blocking-signals">
<div class="code-block-caption"><span class="caption-text">blocking_signals.c</span><a class="headerlink" href="#blocking-signals" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;signal.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="k">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">sig_names</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGHUP&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGINT&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTSTP&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGILL&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTRAP&quot;</span><span class="p">,</span><span class="w">      </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGABRT&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGBUS&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGFPE&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGKILL&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGUSR1&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGSEGV&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGUSR2&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGPIPE&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGALRM&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTERM&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGSTKFLT&quot;</span><span class="p">,</span><span class="w">   </span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGCHLD&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGCONT&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGSTOP&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTSTP&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTTIN&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">22</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGTTOU&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">23</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGURG&quot;</span><span class="p">,</span><span class="w">      </span><span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGXCPU&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGXFSZ&quot;</span><span class="p">,</span><span class="w">     </span><span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGVTALRM&quot;</span><span class="p">,</span><span class="w">   </span><span class="p">[</span><span class="mi">27</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGPROF&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">28</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGWINCH&quot;</span><span class="p">,</span><span class="w">    </span><span class="p">[</span><span class="mi">29</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGIO&quot;</span><span class="p">,</span><span class="w">       </span><span class="p">[</span><span class="mi">30</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGPWR&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">31</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGSYS&quot;</span><span class="p">,</span><span class="w">      </span><span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN&quot;</span><span class="p">,</span><span class="w">    </span><span class="p">[</span><span class="mi">35</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">36</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+2&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">37</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+3&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">38</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+4&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">39</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+5&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">40</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+6&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">41</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+7&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">42</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+8&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">43</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+9&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">44</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+10&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">45</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+11&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">46</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+12&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">47</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+13&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">48</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+14&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">49</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMIN+15&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-14&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">51</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-13&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">52</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-12&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">53</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-11&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">54</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-10&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">55</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-9&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">56</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-8&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">57</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-7&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">58</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-6&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">59</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-5&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">60</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-4&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">61</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-3&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">62</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-2&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[</span><span class="mi">63</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX-1&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;SIGRTMAX&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* sig_atomic_t is an async-signal safe data type */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">sig_atomic_t</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Signal sets for blocking/unblocking signals. */</span>
<span class="kt">sigset_t</span><span class="w"> </span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="n">old_sigset</span><span class="p">;</span>

<span class="cm">/** Record received signal handler */</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span>
<span class="n">sig_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">int</span><span class="w"> </span><span class="n">errno_sav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">errno</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Cache errno */</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Reinstall signal handler */</span>
<span class="w">  </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errno_sav</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Restore errno */</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Initializing Blocked set of signals */</span>
<span class="w">  </span><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span><span class="w">        </span>
<span class="w">  </span><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="no">SIGINT</span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="no">SIGTSTP</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="no">SIGALRM</span><span class="p">);</span><span class="w"> </span>

<span class="w">  </span><span class="cm">/* Changing the disposition of SIGINT and SIGTSTP */</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>
<span class="w">  </span><span class="nf">signal</span><span class="p">(</span><span class="no">SIGTSTP</span><span class="p">,</span><span class="w"> </span><span class="n">sig_handler</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Store old signal mask */</span>
<span class="w">  </span><span class="n">sigprocmask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_sigset</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Loop oscillates between two states</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Blocking signals (5 second sleep)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">sigprocmask</span><span class="p">(</span><span class="no">SIG_BLOCK</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Wait for a signal to become pending */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="n">timespec</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="w">    </span><span class="n">signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigtimedwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signo</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Reset errno on timeout */</span>

<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Signal %d (%s) was pending!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">signo</span><span class="p">,</span><span class="w"> </span><span class="n">sig_names</span><span class="p">[</span><span class="n">signo</span><span class="p">]);</span>

<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;Unblocking signals (5 second sleep)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">alarm</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Wait for a signal to be delivered */</span>
<span class="w">    </span><span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_sigset</span><span class="p">);</span>
<span class="w">    </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* sigsuspend always sets errno to EINTR */</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Signal %d (%s) was caught!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">signo</span><span class="p">,</span><span class="w"> </span><span class="n">sig_names</span><span class="p">[</span><span class="n">signo</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">blocking_signals output</span><a class="headerlink" href="#id12" title="Link to this code"></a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./blocking_signals<span class="w"> </span>
<span class="go">Blocking signals (5 second sleep)</span>
<span class="go">^C	Signal 2 (SIGINT) was pending!</span>
<span class="go">Unblocking signals (5 second sleep)</span>
<span class="go">^Z	Signal 20 (SIGTSTP) was caught!</span>
<span class="go">Blocking signals (5 second sleep)</span>
<span class="go">^C	Signal 2 (SIGINT) was pending!</span>
<span class="go">Unblocking signals (5 second sleep)</span>
<span class="go">^Z	Signal 20 (SIGTSTP) was caught!</span>
<span class="go">Blocking signals (5 second sleep)</span>
<span class="go">^C	Signal 2 (SIGINT) was pending!</span>
<span class="go">Unblocking signals (5 second sleep)</span>
<span class="go">^Z	Signal 20 (SIGTSTP) was caught!</span>
<span class="go">Blocking signals (5 second sleep)</span>
<span class="go">^\Quit (core dumped)</span>

<span class="gp">$ </span>
</pre></div>
</div>
</div>
<p>The <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigprocmask</span></code> system call is used to enable and disable a
blocking set. It takes a first parameter (named how in the prototype) to
indicate the action to be taken. This parameter could be one of the
following values:</p>
<ul class="simple">
<li><p><code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIG_BLOCK</span></code> to add a set of signals to be blocked</p></li>
<li><p><code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIG_UNBLOCK</span></code> to remove a set of signals from the blocked set</p></li>
<li><p><code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIG_SETMASK</span></code> to replace an entire set of blocked signals with
another set</p></li>
</ul>
<p>In state 1 of the loop inside the program, we first use
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigprogmask</span></code> to add the signals in the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">blocked_set</span></code> to the set of
signals currently blocked. The old set of signals is returned in the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">default_set</span></code> set of signals. In our case, this <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">defaul_set</span></code> has no
signals blocked. In state 2 of the loop, <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigprogmask</span></code> is used to
replace the set of blocked signals with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">default_set</span></code> that was saved
with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIG_SETMASK</span></code> parameter. Alternatively, it could just unblock
the same signals with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIG_UNBLOCK</span></code> parameter. The general effect
of this loop is that initially it blocks the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGQUIT</span></code> signals,
as can be seen in the bottom cell of the picture. Once the old set of
blocked signals (<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">default_set</span></code>) is restored in state 2 of the loop,
SIGINT and <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGQUIT</span></code> are no longer blocked and they are delivered. The
program uses a handler function that displays the signal that is
received first, and stops the program naturally with <strong>exit(0)</strong>.</p>
<p>Before entering into state 2, the program reports which signals were
pending. To do so, it uses the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigpending</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigismember</span></code>
system calls that have the following prototypes:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">int</span><span class="w"> </span><span class="n">sigpending</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigpending</span></code> system call retrieves a set of signals that are
pending. As it can be seen in the bottom cell of the previous figure,
the user pressed <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd> and <kbd class="kbd docutils literal notranslate">ctrl</kbd>-<kbd class="kbd docutils literal notranslate">\</kbd> twice each, these produce
the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGQUIT</span></code> signals that are part of the pending signals set
retrieved by the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigpending</span></code> system call (<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pending_set</span></code>). To verify
that a signal is part of a set we use the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sigismember</span></code> system call.
In our example, it is separately checking if the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGINT</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGQUIT</span></code>
signals are members of the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pending_set</span></code> set of signals, and reporting on
it. Notice here that the pending set only reports once per every
different signal received. In other words, it does not matter how many
times a signal is sent, the pending signal set will only contain one
acknowledgment per each kind of signal.</p>
<p>It is important to emphasize that the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGKILL</span></code> signal cannot be
blocked, for the same reason that it cannot be ignored or handled. This
signal guarantees termination of a process, and, therefore the process
cannot do anything about it. On the other hand, it should only be used
as a last resort, because if a process uses a handler to have a clean
exit, without resources left open or engaged, when the <code class="code highlight c c99 docutils literal highlight-c99"><span class="no">SIGKILL</span></code>
signal is received, the process will not be able to use the handler at
all.</p>
</section>
<section id="execution-times">
<h2>Execution Times<a class="headerlink" href="#execution-times" title="Link to this heading"></a></h2>
<p>The time a process takes to run on a computer depends on many factors.
To begin with, it depends on the speed of the CPU, the registers, the
memory and the secondary storage. It also depends on the kind and the
number of instructions in the process, how long the process waits in the
ready queue, how many times the process is interrupted by the kernel,
and how long it waits to go back to the ready queue.With so many factors
to consider, there are many possible time measurements that can be made.
From all these possibilities, the most important to consider are the
following three:</p>
<p>Real Time</p>
<blockquote>
<div><p>The time from when the kernel begins to load it in memory until it is terminated. This corresponds to our classical idea of time keeping.</p>
</div></blockquote>
<dl class="simple">
<dt>User Time</dt><dd><p>The time that a process spends while running in the CPU in user mode. It is smaller than the real time because it only considers the time when the process is in running state, performing instructions. If a process is interrupted many times, the user time adds up all the times the process was executing statements before these interruptions.</p>
</dd>
<dt>System Time</dt><dd><p>The time the kernel takes performing tasks on behalf of the process. This includes the loading time, the time used by the kernel to handle all the interruptions for the process, and the times to do context switching for the process. It does not include any waiting time from the process.</p>
</dd>
</dl>
<p>The command <strong class="program">time</strong> used in a shell provides measurements of these
three times. This command is prefixed to the normal program call to be
made. For example, the following shows the programs <a class="reference internal" href="#compound-c"><span class="std std-ref">compound</span></a> and
<a class="reference internal" href="#id-c"><span class="std std-ref">id</span></a> being timed with the time command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">time</span><span class="w"> </span>./compound<span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">7</span>
<span class="go">	Table of Compounded Amounts</span>
<span class="go">		Created by: ryan</span>
<span class="go">         Amount    After Period</span>
<span class="go">        1000.00        0</span>
<span class="go">        1020.00        1</span>
<span class="go">        1040.40        2</span>
<span class="go">        1061.21        3</span>
<span class="go">        1082.43        4</span>
<span class="go">        1104.08        5</span>
<span class="go">        1126.16        6</span>
<span class="go">        1148.69        7</span>
<span class="go">	Accumulated Interests:148.69</span>

<span class="go">real	0m0.001s</span>
<span class="go">user	0m0.001s</span>
<span class="go">sys	0m0.000s</span>

<span class="gp">$ </span><span class="nb">time</span><span class="w"> </span>./id
<span class="go">My Process ID:                 96145</span>
<span class="go">My Group ID:                   96145</span>
<span class="go">My Parent Process ID:          56072</span>
<span class="go">My Parent Group ID:            56072</span>
<span class="go">My Session ID:                 56072</span>
<span class="go">My Parent Session ID:          56072</span>

<span class="go">Output of `ps&#39;:</span>

<span class="go">    PID    PGRP    PPID    PGID     SID CMD</span>
<span class="go">  56072   56072   56058   56072   56072 /bin/bash --posix</span>
<span class="go">  96145   96145   56072   96145   56072  \_ ./id</span>
<span class="go">  96146   96145   96145   96145   56072      \_ ps --forest -o pid,pgrp,ppid,pgid,sid,cmd</span>

<span class="go">real	0m0.019s</span>
<span class="go">user	0m0.000s</span>
<span class="go">sys	0m0.011s</span>
</pre></div>
</div>
<p>If a process is short and it is not often interrupted, the real time may
be similar to the addition of the user and system times. Notice that the
difference of 5 seconds in these figures on the identify program is due
to sleeping time forced on the process. This waiting time is not added
neither to the user time, nor to the system time.</p>
</section>
<section id="multiprogramming">
<h2>Multiprogramming<a class="headerlink" href="#multiprogramming" title="Link to this heading"></a></h2>
<p>Multiprogramming is the ability of an operating system to hold more than
one process running in memory at the same time. When we open a text
editor to write a program, and at the same time we open a Web Browser to
review a website, while listening to music from our favorite streaming
service, all done in the same computer, we are using multiprogramming.
Each one of these activities may generate one or more processes that are
trying to run on the computer. From the point of view of the user, all
these processes may appear to be running at the same time, but all of
them require access to a CPU to perform their instructions. In the
simplest case with a single CPU in the computer, all processes will take
turns accessing it. The operating system is the one deciding which
process accesses the CPU at any given time and for how long. Therefore,
the decisions that it makes will affect the performance of each one of
the applications running in the system. This is one of the main
responsibilities for the operating system, as a CPU scheduler.</p>
</section>
<section id="forking">
<h2>Forking<a class="headerlink" href="#forking" title="Link to this heading"></a></h2>
<p>In Linux, multiprogramming is achieved by a technique called
<strong>forking</strong>. This requires that a process “clones” itself using the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">fork</span></code> system call with no parameters. When a process makes this
call, the kernel creates a copy of the current process that will run
independently and concurrently with the original process and all other
processes already in the system. The newly created process (called the
child process) receives copies of all segments from the original process
(called the parent process), as well as copies of the file descriptors.
After the call to fork, both processes may begin execution of the next
sentence in the program. If no allowances are made, both processes may
execute the same sentences when they take control of the CPU. However,
the call to fork returns different values for parent and child
processes. The parent process receives the process ID from the children
just created, however the children process receives a value of zero.
This fact can be used to request each process to perform different
instructions. <a class="reference internal" href="#simple-fork-c"><span class="std std-ref">simple_fork.c</span></a> shows a process that forks. The value this system call returns is
used in a switch statement to assign different instructions to parent
and child processes. Notice that if the call to fork returns a -1 if the
call fails. The fork system call is declared in the <code class="file docutils literal notranslate"><span class="pre">unistd.h</span></code>
header.</p>
<div class="literal-block-wrapper docutils container" id="simple-fork-c">
<div class="code-block-caption"><span class="caption-text">simple_fork.c</span><a class="headerlink" href="#simple-fork-c" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/wait.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="k">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">fork_result</span><span class="p">;</span><span class="w"> </span><span class="c1">// status of the fork</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">fork_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span><span class="w"> </span><span class="cm">/* error */</span>
<span class="w">      </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fork&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* The child proc sees the return value from fork() as 0 */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span>
<span class="w">      </span><span class="cm">/* Child Zone */</span>
<span class="w">      </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpid</span><span class="p">();</span>
<span class="w">      </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;I am the child process.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">             </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">The fork gave me a %d, but my PID is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">fork_result</span><span class="p">,</span>
<span class="w">             </span><span class="n">pid</span><span class="p">);</span>

<span class="w">      </span><span class="cm">/* Typically, the child has its own exit path distinct from the parent,</span>
<span class="cm">       * though it could also be allowed to continue executing past the switch</span>
<span class="cm">       * block */</span>
<span class="w">      </span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* The parent proc sees the return value from fork() as the child&#39;s pid */</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="cm">/* Parent zone */</span>
<span class="w">      </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpid</span><span class="p">();</span>
<span class="w">      </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;I am the parent process.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">             </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">The fork gave me my child PID (%d), but my own PID is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">fork_result</span><span class="p">,</span>
<span class="w">             </span><span class="n">pid</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="cm">/* Parent waits for child to exit */</span>
<span class="w">  </span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/* Parent exit */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>When the program runs, it produces a result like:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./simple_fork
<span class="go">I am the parent process.</span>
<span class="go">	The fork gave me my child PID (97160), but my own PID is 97159</span>
<span class="go">I am the child process.</span>
<span class="go">	The fork gave me a 0, but my PID is 97160</span>
</pre></div>
</div>
<p>Since the parent and child run in parallel after forking, it is also possible to observe,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./simple_fork
<span class="go">I am the parent process.</span>
<span class="go">	The fork gave me my child PID (97160), but my own PID is 97159</span>
<span class="go">I am the child process.</span>
<span class="go">	The fork gave me a 0, but my PID is 97160</span>
</pre></div>
</div>
<p>As previously indicated, copies of the file descriptors from a parent
process are given to the child process. Because they are copies, if any
of the processes modifies the attributes of the files they reference,
like offset placement or access mode, all these changes will be visible
and relevant to both processes. If the programmer wants to keep
different attributes, they should create <em>new</em> file descriptors after fork.</p>
<p>Even though a child process should receive copies of the page table after fork, this is actually done only when the children require a change in any of them. This strategy is called “copy-on-write” (CoW) and it avoids doing copies of resources that may not be needed. Before that, both parent process and children process just keep references to the same segments. If any of the processes requires to update the stack or heap, or maybe load a different set of instructions for the text, this is when the kernel will generate the copy with the appropriate change. This is particularly useful in cases where a child is created to run a different program than the one in the parent process, as we will see later, since it avoids expensive copying of a process image that is about to be replaced.</p>
<p>A typical application of forking is to have a main program that
generates tasks, each one to be handled by a different child process.
The parent process waits for these processes to complete. The following
listing shows the basic structure of such an application in a program
called <a class="reference internal" href="#fork-cycle-c"><span class="std std-ref">fork_cycle.c</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fork-cycle-c">
<div class="code-block-caption"><span class="caption-text">fork_cycle.c</span><a class="headerlink" href="#fork-cycle-c" title="Link to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/wait.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fork_limit</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Number of requested forks */</span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">child_exit_pid</span><span class="p">;</span><span class="w"> </span><span class="cm">/* PID of returning child */</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">child_exit_count</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Number of children finishing its tasks */</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Sleeping time for a child process */</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Counter */</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="n">fork_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Usage: %s FORK_LIMIT&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="cm">/* Create fork_count child processes */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">fork_limit</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">fork</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">-1</span><span class="p">:</span>
<span class="w">        </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fork&quot;</span><span class="p">);</span>

<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// Child prints, sleeps and exits</span>
<span class="w">        </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getpid</span><span class="p">();</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Process %d created. Waiting %d seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">pid</span><span class="p">,</span>
<span class="w">                </span><span class="n">fork_limit</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="n">fork_limit</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">child_exit_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">child_exit_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">child_exit_pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ECHILD</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* No more children */</span>
<span class="w">        </span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;wait&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">child_exit_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Child #%d (PID %d) exited</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">           </span><span class="n">child_exit_count</span><span class="p">,</span>
<span class="w">           </span><span class="n">child_exit_pid</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;All children have exited!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./fork_cycle<span class="w"> </span><span class="m">7</span>
<span class="go">Process 98716 created. Waiting 6 seconds.</span>
<span class="go">Process 98715 created. Waiting 7 seconds.</span>
<span class="go">Process 98717 created. Waiting 5 seconds.</span>
<span class="go">Process 98718 created. Waiting 4 seconds.</span>
<span class="go">Process 98720 created. Waiting 2 seconds.</span>
<span class="go">Process 98719 created. Waiting 3 seconds.</span>
<span class="go">Process 98721 created. Waiting 1 seconds.</span>
<span class="go">Child #1 (PID 98721) exited</span>
<span class="go">Child #2 (PID 98720) exited</span>
<span class="go">Child #3 (PID 98719) exited</span>
<span class="go">Child #4 (PID 98718) exited</span>
<span class="go">Child #5 (PID 98717) exited</span>
<span class="go">Child #6 (PID 98716) exited</span>
<span class="go">Child #7 (PID 98715) exited</span>
<span class="go">All children have exited!</span>
</pre></div>
</div>
<p>This program expects an integer parameter to indicate the number of
children to be created. A loop creates these children. Each one could be
performing a different task, but in this program, they just pause for a
different number of seconds with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">sleep</span></code> system call and then exit.
The parent process waits for them with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code> system call in a loop; <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code> returns the process id of the exiting child process. If no more children remain, it fails and sets <code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">ECHILD</span></code>. The parent process increments the count of returning
children after any new one is received. The loop ends when all children
have returned.</p>
</section>
<section id="the-exec-system-call">
<h2>The exec() system call<a class="headerlink" href="#the-exec-system-call" title="Link to this heading"></a></h2>
<p>Sometimes it is necessary for a child process to forgo the sets of
instructions it inherited from its parent process and open a complete
new program.This can be done with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">exec</span></code> system call. Once this
call is made, the kernel will reload the virtual memory address space of
the child process with a new program and update the registers to start
the process. However, many other elements inherited from the parent
process will remain in place. The process will keep its PID, as well as
its parent ID, process group IDs, and session ID. It also keeps all the
environment variables inherited from the parent process and the file
descriptors with all its settings.The process will execute the new code
and when it ends, it will exit and never come back to the parent
process. There will be no notification of completion or return to the
parent process.</p>
<p>In reality, the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">exec</span></code> system call does not exist. This is just the
generic name for a set of system calls, all beginning with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">exec</span></code>
prefix. The most basic system call is <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execve</span></code>. All other variants
are convenient ways to prepare the call to <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execve</span></code> with different
parameters. Basically, all these system calls require three main
parameters: 1.The location and name of the program to be executed, 2.
The set of all the strings containing the arguments for the program to
be executed, just like the <code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">argv</span></code> parameter that would be created for
that program, and 3.The environment variables that are passed to the
program to be executed.The variants of this system call prepare these
parameters in different ways. It is easier to remember all of them if we
relate their names with the parameters they request as described below.</p>
<p>The first decision a programmer has to make on selecting an <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">exec</span></code>
system call is to decide if the arguments for the program to be executed
are going to be supplied together arranged inside an array (just like
<code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">argv</span><span class="p">[]</span></code>) or if they are going to be supplied separately in an
explicit list. In the first case we must select a system call starting
with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execv</span></code> prefix, for a vector (another name for an array). In
the second case we must select a system call starting with the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execl</span></code>
prefix, for a list. These system calls have the following prototypes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">execv</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">pathname</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="kt">int</span><span class="w"> </span><span class="n">execl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pathname</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="p">...</span>
<span class="w">               </span><span class="cm">/*, (char *) NULL */</span><span class="p">);</span>
</pre></div>
</div>
<p>Both require a pointer to the pathname and filename of the program to be executed as the first parameter. The pathname can be absolute or relative. The arguments are passed in either as an array of <code class="code highlight c c99 docutils literal highlight-c99"><span class="k">char</span><span class="w"> </span><span class="o">*</span></code>, or as a variadic list of <code class="code highlight c c99 docutils literal highlight-c99"><span class="k">char</span><span class="w"> </span><span class="o">*</span></code>. The first argument should be the name of the program–usually the same as <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pathname</span></code>. Next follow the remaining arguments, and finally a null pointer to indicate the end of the array or argument list. Notice that there is no “number of arguments” argument–these functions have no way to know when they’ve reached the end of the list if you forget a null pointer! (this is a very common mistake).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In some cases, the first argument is not the same as the file path. For example, some monolithic programs present themselves as two separate programs. An example is the program <strong class="program">vim</strong> which will change its behavior when executed with its first argument as <strong class="program">vi</strong>. This is also used in other cases, such as to have a single utility implement both <strong class="program">zip</strong> and <strong class="program">unzip</strong>. Taken to an extreme, the BusyBox project packages an entire set of POSIX utilities into a single monolithic program for use on resource-constrained embedded systems. All utilities in <code class="file docutils literal notranslate"><span class="pre">/bin/</span></code> are just links to this one program, which basically has a massive lookup table based on the value of <code class="code highlight c c99 docutils literal highlight-c99"><span class="nv">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code>.</p>
</div>
<p>Aside from <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execl</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execv</span></code>, there are two other sets of functions in the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">exec</span></code> family; the first are <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execlp</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execvp</span></code>. These two are the most commonly used in practice; they differ from those above in that they perform command lookup by searching the directories listed in the <code class="docutils literal notranslate"><span class="pre">PATH</span></code> environment variable–just like the shell does–if the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pathname</span></code> argument doesn’t contain any slashes (<code class="docutils literal notranslate"><span class="pre">/</span></code>). Otherwise the behavior is identical.</p>
<p>The second set of functions are <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execle</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execve</span></code>. These functions allow the caller to pass in a custom set of environment variables, rather than have them inherited by the child process. They both have the same function signature as the previous functions, with an additional final argument which is a pointer to a null-terminated list of null-terminated environment strings. These are typically used for security purposes, to empty the environment of a child process before it is executed, so that things such as the user’s name and other configuration settings aren’t leaked to untrusted processes,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">execle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pathname</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="cm">/*, (char *) NULL, char *const envp[] */</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">execve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">argv</span><span class="p">[],</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">envp</span><span class="p">[]);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execle</span></code> takes a variadic list of arguments, but it requires an array of environment strings, like <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execve</span></code></p>
</div>
<p>Finally, there is one more pair of functions, <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execvpe</span></code> and <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execlpe</span></code> which combine the properties of the <code class="docutils literal notranslate"><span class="pre">e</span></code> functions with the properties of the <code class="docutils literal notranslate"><span class="pre">p</span></code> functions, accepting an additional environment variable argument, and performing command lookup if the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">pathaname</span></code> argument doesn’t contain any slashes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code highlight c c99 docutils literal highlight-c99"><span class="n">execvpe</span></code> is a nonstandard GNU-extension.</p>
</div>
<p>Consider the following program, <a class="reference internal" href="#xargs-c"><span class="std std-ref">xargs.c</span></a>, which is a basic implementation of the <strong class="program">xargs</strong> utility. It repeatedly executes the command that is passed to it, with any prefix arguments, followed by additional arguments taken as white-space separated tokens on standard input, up to the argument limit <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">ARG_MAX</span></code>,</p>
<div class="literal-block-wrapper docutils container" id="xargs-c">
<div class="code-block-caption"><span class="caption-text">xargs.c</span><a class="headerlink" href="#xargs-c" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ctype.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;err.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;wait.h&gt;</span>

<span class="cm">/* Maximum arguments to pass to each instance of a child process */</span>
<span class="cp">#ifndef ARG_MAX</span>
<span class="cp">#define ARG_MAX 1023</span>
<span class="cp">#endif</span>

<span class="cm">/* Command default when argc &lt; 2 */</span>
<span class="cp">#ifndef DFL_CMD</span>
<span class="cp">#define DFL_CMD &quot;echo&quot;</span>
<span class="cp">#endif</span>

<span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_MAX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">DFL_CMD</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="k">int</span><span class="w"> </span><span class="n">args_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/** Read one whitespace-delimited token from strem */</span>
<span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">read_token</span><span class="p">(</span><span class="no">FILE</span><span class="w"> </span><span class="o">*</span><span class="nf">stream</span><span class="p">);</span>

<span class="k">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">memcpy</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nv">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nv">argc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">args_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">argc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">!</span><span class="n">eof</span><span class="p">;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args_start</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARG_MAX</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Clean up if there is something stored here</span>
<span class="cm">       * from a previous iteration */</span>
<span class="w">      </span><span class="nf">free</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">      </span><span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="nf">tok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_token</span><span class="p">(</span><span class="nv">stdin</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nf">tok</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">feof</span><span class="p">(</span><span class="nv">stdin</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="cm">/* On end of input, null-terminate the args array</span>
<span class="cm">           * and set the eof flag */</span>
<span class="w">          </span><span class="nf">clearerr</span><span class="p">(</span><span class="nv">stdin</span><span class="p">);</span>
<span class="w">          </span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">          </span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;read token&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* Store a copy of the next token */</span>
<span class="w">      </span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">strdup</span><span class="p">(</span><span class="nf">tok</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">fork</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">-1</span><span class="o">:</span>
<span class="w">        </span><span class="cm">/* Error */</span>
<span class="w">        </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fork&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span>
<span class="w">        </span><span class="cm">/* Child process */</span>
<span class="w">        </span><span class="n">execvp</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">        </span><span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exec&quot;</span><span class="p">);</span><span class="w"> </span><span class="cm">/* catch exec() failure */</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Wait for the child process to finish */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">errx</span><span class="p">(</span><span class="mi">124</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s: exited with status 255; aborting&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span>
<span class="n">read_token</span><span class="p">(</span><span class="no">FILE</span><span class="w"> </span><span class="o">*</span><span class="nf">stream</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">line_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Skip whitespace */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="nf">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="n">sp</span><span class="o">++</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Found token */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Reached EOL; read a new line */</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">line_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">line_n</span><span class="p">,</span><span class="w"> </span><span class="nf">stream</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line_len</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nf">assert</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Sanity check */</span>

<span class="w">  </span><span class="cm">/* Store location of the token */</span>
<span class="w">  </span><span class="k">char</span><span class="w"> </span><span class="o">*</span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Scan to end of token */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="o">!</span><span class="nf">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">sp</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/* Terminate token */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;</span><span class="se">\0</span><span class="sc">&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Compiled with a small <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">ARG_MAX</span></code> value of 3 (program name and two additional arguments), we can see the effect below, when the alphabet is piped into it,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nv">CPPFLAGS</span><span class="o">=</span>-DARG_MAX<span class="o">=</span><span class="m">3</span><span class="w"> </span>make<span class="w"> </span>xargs
<span class="go">cc  -DARG_MAX=3   xargs.c   -o xargs</span>
<span class="gp">$</span><span class="nb">echo</span><span class="w"> </span><span class="o">{</span>a..z<span class="o">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>./xargs
<span class="go">a b</span>
<span class="go">c d</span>
<span class="go">e f</span>
<span class="go">g h</span>
<span class="go">i j</span>
<span class="go">k l</span>
<span class="go">m n</span>
<span class="go">o p</span>
<span class="go">q r</span>
<span class="go">s t</span>
<span class="go">u v</span>
<span class="go">w x</span>
<span class="go">y z</span>
</pre></div>
</div>
<p>In this output, we can surmise that <strong class="program">echo</strong> is being executed thirteen times, printing two letters of the alphabet each time. The xargs utility is used for performing batch operations. For example, the <strong class="program">find</strong> utility writes a list of files matching a criteria to standard out. Piping this into <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">xargs</span></code> allows one to easily perform operations with those files. Suppose we wish to delete object files after compiling a program, the following operation, <code class="code highlight console docutils literal highlight-console"><span class="go">find . -name &#39;*.o&#39; | xargs rm --</span></code>, invokes <strong class="program">rm</strong> with many file names, repeatedly until exhausting the list. In contrast, removing the files one-by-one would be much less efficient due to the overhead of spawning a new process for each file.</p>
</section>
<section id="of-orphans-zombies-and-daemons">
<h2>Of orphans, zombies and daemons<a class="headerlink" href="#of-orphans-zombies-and-daemons" title="Link to this heading"></a></h2>
<p>Parent processes usually wait for their children to end execution, and
when they do, the parent process requests their removal from the table
of running processes managed by the kernel. Consequently, all resources
allocated to the children processes are released, to be used by other
processes, and their entry in the table of running processes is removed.</p>
<p>Children processes whose parents terminate before themselves are
considered <strong>orphans</strong>. Because no process may be left without a
parent, the <strong class="program">init</strong> process “grandfathers” all orphaned children. The
<strong class="program">init</strong> process becomes the parent ID of these processes. The orphaned
processes are then “waited” by the <strong class="program">init</strong> process, and when they
finish, <strong class="program">init</strong> removes them from the table of running processes
managed by the kernel and deallocates its resources.This is the reason
why the <strong class="program">init</strong> process is also known as the <strong>reaper process</strong>.</p>
<p>If a child process terminates before the parent process issues the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code> system call, the kernel will still release its resources, but
a record of the child process will remain in the table of running
processes. This allows the parent a chance to issue the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code>
system call at a later stage and receive a reply from the terminated
process. Because in practice the child process no longer exists, but
there is still a record of it in the table of running processes, this
process becomes what is known as a <strong>zombie</strong> process. Zombie processes
cannot be killed by normal means, and the only way to eliminate them is
to issue a call to <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code>. If zombie processes are not removed from
the table of running processes they may remain there indefinitely.
Zombie processes in which the parent terminates without issuing the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">wait</span></code> system call become orphan processes, and therefore are waited
by the init process that removes them from the table of running
processes.</p>
<p>Other important processes in the operation of Linux systems are
<strong>daemons</strong>. Daemons are special background processes, unconnected to a
terminal, that provide special services for the system. Because these
services may be needed at any point of the system operation, they are
usually running from the system start-up through shut down. Examples of
daemons are the processes that control networked printers, the ones that
allow secure remote login to the system, and the ones that handle
requests to web page servers.</p>
</section>
<section id="process-resource-limits">
<h2>Process Resource Limits<a class="headerlink" href="#process-resource-limits" title="Link to this heading"></a></h2>
<p>Resources in a computer are limited. For example, there is just a
certain amount of memory in RAM, a certain storage capacity in files,
and a certain amount of time to execute programs. All these limits can
be set, so that all users can fairly share these resources. To do so,
the following two system calls from <code class="file docutils literal notranslate"><span class="pre">sys/resource.h</span></code> can
be used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">getrlimit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">resource</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rlimit</span><span class="w"> </span><span class="o">*</span><span class="n">rlp</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">setrlimit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">resource</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rlimit</span><span class="w"> </span><span class="o">*</span><span class="n">rlp</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getrlimit</span></code> system call retrieves the limits of the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">resource</span></code>
operand into a <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlimit</span></code> structure, while the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">setrlimit</span></code> system
call sets the limits for the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">resource</span></code> operand from the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlimit</span></code>
structure.</p>
<p>The various system resources are codified with a number that is also
identified by a name. Some of the most useful resource names are shown
below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head stub"><p>Resource Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><th class="stub"><p>RLIMIT_CPU</p></th>
<td><p>CPU time in seconds</p></td>
</tr>
<tr class="row-odd"><th class="stub"><p>RLIMIT_AS</p></th>
<td><p>Process virtual memory size in bytes</p></td>
</tr>
<tr class="row-even"><th class="stub"><p>RLIMIT_STACK</p></th>
<td><p>Size of the stack segment in bytes</p></td>
</tr>
<tr class="row-odd"><th class="stub"><p>RLIMIT_DATA</p></th>
<td><p>Process data segment in bytes</p></td>
</tr>
<tr class="row-even"><th class="stub"><p>RLIMIT_NOFILE</p></th>
<td><p>Maximum number of file descriptors plus 1</p></td>
</tr>
<tr class="row-odd"><th class="stub"><p>RLIMIT_FSIZE</p></th>
<td><p>File size in bytes</p></td>
</tr>
<tr class="row-even"><th class="stub"><p>RLIMIT_NPROC</p></th>
<td><p>Number of processes open for the real user ID</p></td>
</tr>
</tbody>
</table>
<p>The <code class="code highlight c c99 docutils literal highlight-c99"><span class="k">struct</span><span class="w"> </span><span class="n">rlimit</span></code> type has the following members,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">rlimit</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="kt">rlim_t</span><span class="w">  </span><span class="n">rlim_cur</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Soft limit */</span>
<span class="w">         </span><span class="kt">rlim_t</span><span class="w">  </span><span class="n">rlim_max</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Hard limit (ceiling for rlim_cur) */</span>
<span class="w">      </span><span class="p">};</span>
</pre></div>
</div>
<p>We use this structure, because every user may have a hard limit for a
resource over which it cannot go. That is the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlim_max</span></code>. However, a
user may be using less than that limit, therefore the current limit is
specified by <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlim_cur</span></code>. Privileged users, like the superuser or root,
may modify these limits as they see fit, as long as the current limit is
smaller than or equal to the hard limit. Other users may lower the
current limit, or raise it up to the hard limit, but cannot go over it.</p>
<p>The following figure shows the program <a class="reference internal" href="#show-limits-c"><span class="std std-ref">show_limits.c</span></a> that displays
the soft and hard limits of some resources. This program uses a
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">print_rlimit</span></code> function taken from “<em>The Linux Programming Interface</em>” by
Michael Kerrisk (recommended textbook for this course). This function
uses the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">getrlimit</span></code> system call to obtain the limits , but before
printing them, it checks if they are too large, and if so it prints
“infinite” as the value. Similarly, it also checks if the specific Linux
implementation has a limit that is beyond the number allowed to be
stored in the <code class="code highlight c c99 docutils literal highlight-c99"><span class="kt">rlim_t</span></code> data type. If that is the case, the <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlim_cur</span></code> may
hold a predefined <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">RLIM_SAVED_CUR</span></code> value, and equivalently, the
<code class="code highlight c c99 docutils literal highlight-c99"><span class="n">rlim_max</span></code> may hold a predefined <code class="code highlight c c99 docutils literal highlight-c99"><span class="n">RLIM_SAVED_MAX</span></code> value. The detection
of these values will make the function to print “unrepresentable”
instead. The bottom cell shows the program running for a privileged
user.</p>
<div class="literal-block-wrapper docutils container" id="show-limits-c">
<div class="code-block-caption"><span class="caption-text">show_limits.c</span><a class="headerlink" href="#show-limits-c" title="Link to this code"></a></div>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/resource.h&gt;</span>

<span class="c1">// Function print_r_limit taken from Listing 36-2 Page 758 from</span>
<span class="c1">// The Linux Programming Interface by Michael Kerrisk</span>
<span class="k">int</span><span class="w"> </span><span class="n">print_r_limit</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>

<span class="k">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nv">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;CPU Time limits (seconds):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_CPU</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;Process Virtual Memory limits (bytes):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_AS</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;Stack Segment limits (bytes):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_STACK</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;Process Data Segment limits (bytes):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_DATA</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;Number of File Descriptors (+1):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_NOFILE</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;File Size (bytes):&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_FSIZE</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_r_limit</span><span class="p">(</span><span class="s">&quot;Number of Processes allowed to open:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RLIMIT_NPROC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Print &#39;msg&#39; followed by limits for &#39;resource&#39; */</span>
<span class="kt">int</span>
<span class="n">print_r_limit</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">resource</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="n">rlimit</span><span class="w"> </span><span class="n">rlim</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rlim</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%s soft=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_cur</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RLIM_INFINITY</span><span class="p">)</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;infinite&quot;</span><span class="p">);</span>
<span class="cp">#ifdef RLIM_SAVED_CUR </span><span class="cm">/* Not defined on some implementations */</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_cur</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RLIM_SAVED_CUR</span><span class="p">)</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;unrepresentable&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%lld&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_cur</span><span class="p">);</span>

<span class="w">  </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;; hard=&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_max</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RLIM_INFINITY</span><span class="p">)</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;infinite</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef RLIM_SAVED_MAX </span><span class="cm">/* Not defined on some implementations */</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_max</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RLIM_SAVED_MAX</span><span class="p">)</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;unrepresentable&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">rlim</span><span class="o">.</span><span class="n">rlim_max</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./show_limits
<span class="go">CPU Time limits (seconds): soft=infinite; hard=infinite</span>
<span class="go">Process Virtual Memory limits (bytes): soft=infinite; hard=infinite</span>
<span class="go">Stack Segment limits (bytes): soft=8388608; hard=infinite</span>
<span class="go">Process Data Segment limits (bytes): soft=infinite; hard=infinite</span>
<span class="go">Number of File Descriptors (+1): soft=1024; hard=524288</span>
<span class="go">File Size (bytes): soft=infinite; hard=infinite</span>
<span class="go">Number of Processes allowed to open: soft=62720; hard=62720</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ryan Gambord &lt;Ryan.Gambord@oregonstate.edu&gt;.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>